digraph FSM {
  rankdir=LR;
  size="10,5";
  
  node [shape = circle, style=filled, fillcolor=lightblue];

  // Define states
  Idle [label="Idle"];
  SENDING_CELL1 [label="SENDING_CELL1"];
  SENDING_CELL2 [label="SENDING_CELL2"];
  SENDING_CELL3 [label="SENDING_CELL3"];

  // Define transitions (Process 1: Combinatorial logic for state transitions)
  Idle -> SENDING_CELL1 [label="sink_sop = 1 & sink_valid = 1"];
  SENDING_CELL1 -> SENDING_CELL2 [label="byte_counter == 64"];
  SENDING_CELL2 -> SENDING_CELL3 [label="byte_counter == 128"];
  SENDING_CELL3 -> Idle [label="sink_eop = 1 & sink_valid = 0"];

  // Add auxiliary states if necessary
  SENDING_CELL3 -> SENDING_CELL2 [label="sink_ready = 0 (Backpressure)"];
  SENDING_CELL2 -> SENDING_CELL1 [label="sink_ready = 0 (Backpressure)"];

  // Sequential logic (Process 2: Sequential state updates)
  Idle [xlabel="state <= Idle"];
  SENDING_CELL1 [xlabel="state <= SENDING_CELL1"];
  SENDING_CELL2 [xlabel="state <= SENDING_CELL2"];
  SENDING_CELL3 [xlabel="state <= SENDING_CELL3"];

  // Outputs (Process 3: Combinatorial logic for outputs)
  Idle -> SENDING_CELL1 [headlabel="source_valid = 1, source_data = sink_data"];
  SENDING_CELL1 -> SENDING_CELL2 [headlabel="sink_ready = 1"];
  SENDING_CELL2 -> SENDING_CELL3 [headlabel="source_channel = sink_data[7:0]"];
  SENDING_CELL3 -> Idle [headlabel="source_eoc = 1"];
  
  // Graph Styling
  edge [fontname="Arial", fontsize=10];
  node [fontname="Arial", fontsize=12];
}

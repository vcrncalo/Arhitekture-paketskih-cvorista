digraph FSM {
    // Definicija izgleda grafa
    rankdir=LR;
    node [shape=circle, fixedsize=false, width=1.2];
    
    // Definicija stanja
    IDLE [shape=doublecircle, label="IDLE"];
    PRIMI_PAKET [label="PRIMI_PAKET"];
    POŠALJI_ĆELIJU [label="POŠALJI_ĆELIJU"];
    ČEKAJ_READY [label="ČEKAJ_READY"];
    PADDING [label="PADDING"];
    
    subgraph cluster_process1 {
        style=dotted;
        color=blue;
        label="PROCES 1: Kombinatorna logika (next state <= ftran(state, inputs))";
        
        // PROCES 1: Kombinatorna logika za tranzicije i ažuriranje registara
        
        // Tranzicije između stanja
        IDLE -> PRIMI_PAKET [label="sink_sop"];
        PRIMI_PAKET -> POŠALJI_ĆELIJU [label="sink_eop"];
        PRIMI_PAKET -> ČEKAJ_READY [label="!source_ready // backpressure"];
        POŠALJI_ĆELIJU -> PRIMI_PAKET [label="!last_cell & source_ready"];
        POŠALJI_ĆELIJU -> ČEKAJ_READY [label="!source_ready // backpressure"];
        POŠALJI_ĆELIJU -> PADDING [label="last_cell & source_ready"];
        PADDING -> IDLE [label="padding_done & source_ready"];
        PADDING -> ČEKAJ_READY [label="!source_ready // backpressure"];
        ČEKAJ_READY -> POŠALJI_ĆELIJU [label="source_ready"];
        
        // Ažuriranja registra
        PRIMI_PAKET [label="next_state = PRIMI_PAKET\ndata_buffer <= sink_data\n// next_state, data_buffer_next, padding_count se računaju"];
        POŠALJI_ĆELIJU [label="next_state = POŠALJI_ĆELIJU\ndata_buffer_next <= data_buffer - cell_size\n// next_state, data_buffer_next se računaju"];
        ČEKAJ_READY [label="next_state = ČEKAJ_READY\n// next_state se računa"];
        PADDING [label="next_state = PADDING\npadding_count <= padding_size\npadding_next <= padding_next - 1\ndata_buffer_next <= 0\n// next_state, padding_count, padding_next, data_buffer_next se računaju"];
    }
    
    // PROCES 2: Sekvencijalna logika za registre
    subgraph cluster_process2 {
        label="PROCES 2: Sekvencijalna logika (state <= next state)";
        style=dotted;
        color=green;
        
        node [shape=box];
        registri [label="state <= next_state\npadding_count <= padding_next\ndata_buffer <= data_buffer_next\ncell_size <= constant\n// state, padding_count, data_buffer se ažuriraju"];
    }
    
    // PROCES 3: Kombinatorna logika za izlaze
    subgraph cluster_process3 {
        label="PROCES 3: Kombinatorna logika za izlaze (outputs <= fout(state))";
        style=dotted;
        color=red;
        
        node [shape=box];
        izlazi [label="source_valid = (state == POŠALJI_ĆELIJU or state == PADDING)\nsource_sop = (state == POŠALJI_ĆELIJU and data_buffer == initial_data_size)\nsource_eop = (state == PADDING)\nsource_data = data_buffer[0:cell_size]\nsink_ready = (state == IDLE or state == PRIMI_PAKET)\npadding_done = (padding_count == 0)\n// source_valid, source_sop, source_eop, source_data, sink_ready, padding_done se računaju"];
    }
    
    // Clock, Reset, and Enable
    node [shape=diamond];
    clk_rst [label="clk\nreset\nenable"];
    
    // Connections between processes
    clk_rst -> registri [style=dotted];
    registri -> izlazi [style=dotted];
    
    // Assumptions
    node [shape=note, style=dashed];
    assumptions [label="Pretpostavke:\n- Podaci se primaju putem 'sink' interfejsa.\n- Podaci se šalju putem 'source' interfejsa.\n- 'cell_size' je konstanta.\n- 'initial_data_size' je početna veličina paketa podataka.\n- data_buffer mora biti dovoljno velik da primi cijeli paket podataka.\n- Padding se dodaje kako bi ukupna veličina podataka bila višekratnik od 'cell_size' (Zero Padding).\n- FSM se resetuje u IDLE stanje kada se reset aktivira.\n- Backpressure se kontroliše pomoću source_ready i sink_ready signala.\n- 'last_cell' signal se generiše kada je preostala veličina podataka manja ili jednaka od 'cell_size'.\n- padding_size = (cell_size - (initial_data_size % cell_size)) % cell_size"];
}
